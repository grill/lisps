(+ 2 2)
(quote (testing 1 (2.0) -3.14e159))
(+ (* 2 100) (* 1 10))
(if (> 6 5) (+ 1 1) (+ 2 2))
(if (< 6 5) (+ 1 1) (+ 2 2))
(define x 3)
(x)
(+ x x)
(begin (define x 1) (set! x (+ x 1)) (+ x 1))
((lambda (x) (+ x x)) 5)
(define twice (lambda (x) (* 2 x)))
(twice 5)
(define compose (lambda (f g) (lambda (x) (f (g x)))))
((compose twice twice) 5)
((compose list twice) 5)						#geht nicht
(define repeat (lambda (f) (compose f f)))
((repeat twice) 5)
((repeat (repeat twice)) 5)						# fail aus unerfindlichen gruenden
(define fact (lambda (n) (if (<= n 1) 1 (* n (fact (- n 1))))))
(fact 3)
(fact 50) 								# zu gross fuer int
(define abs (lambda (n) ((if (> n 0) + -) 0 n)))
(list (abs -3) (abs 0) (abs 3))
(define combine (lambda (f) (lambda (x y) (if (null? x) (list) (f (list (car x) (car y)) ((combine f) (cdr x) (cdr y)))))))
(define zip (combine cons))
(zip (list 1 2 3 4) (list 5 6 7 8))		# falsches Erg ??
(define riff-shuffle (lambda (deck) (begin (define take (lambda (n seq) (if (<= n 0) (quote ()) (cons (car seq) (take (- n 1) (cdr seq)))))) (define drop (lambda (n seq) (if (<= n 0) seq (drop (- n 1) (cdr seq))))) (define mid (lambda (seq) (/ (length seq) 2))) ((combine append) (take (mid deck) deck) (drop (mid deck) deck))))) # zu lang fuer readline !!
(riff-shuffle (list 1 2 3 4 5 6 7 8))
((repeat riff-shuffle) (list 1 2 3 4 5 6 7 8))
(riff-shuffle (riff-shuffle (riff-shuffle (list 1 2 3 4 5 6 7 8))))


### new tests ###
(define x (list 0 1 2 3 4 5 6 7 8 9))
(length x)
(car (cdr x))

### take x'th element of list
(define element (lambda (x l) (if (> x 0) (element (- x 1) (cdr l)) (car l))))

### map
(define map (lambda (f l) (if (> (length l) 0) (cons (f (car l)) (map f (cdr l))) (list ))))
(map twice x)
