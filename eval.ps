/vars << >> def
/par_arr [] def

/dictionary <<
(+) {{myop add}} (-) {{myop sub}} (*) {{myop mul}} (/) {{myop div}}
(not) {{getval not}} (>) {{myop gt}} (<) {{myop lt}} (>=) {{myop ge}}
(<=) {{myop le}} (=) {{myop eq}} (equal?) {{myop eq}} (if) {{myif2}}
(quote) {{quote}} (define) {{mydef2}} (set!) {{myset2}} (begin) { prebegin {mybegin}}
(equal?) {{eq}} (eq?) {{}} (length) {{getval length}} (cons) {{}} (car) {{}}
(cdr) {{}} (append) {{}} (list) {{}} (list?) {{}} (null?) {{}}
(lambda) {lambda2}
 >> def

/mybegin {
   mark exch % set mark where this commands parameter begins
   { getVal } forall % evaluate each subexpression
   ] dup length 1 sub get % make array of all outputs and get last one
} def

/prebegin {
   ] mark exch % make an array of all parameters begin will get and recreate the used mark
} def

/array_to {
  dup 0 ge
  { mark exch dup { dup 1 sub } repeat ] }
  { [] }
  ifelse
} def

/add_par { % val var - var val (par_arr added par)
  exch 2 array astore dup
    pstack (........\n) print
  par_arr aload length -1 roll
    pstack (........\n) print
  par_arr length 1 add array astore
  /par_arr exch def
  aload pop
} def

/printdict {
 mark exch { } forall pstack ] pop
} def

/setpars {
  dup length 2 add 3 -1 roll exch 1 roll
  pstack (asdfasdfasdf\n) print

  dup dup length 2 add 1 roll
  length array astore
  dup length 1 sub array_to
  {
    % var_array val_array num
    dup 3 -1 roll dup 4 1 roll exch get
    % var_array val_array num val
    exch 4 -1 roll dup 5 1 roll exch get
    % var_array val_array val var
    add_par
    mydef3 % var val
    pop
    % exch vars 3 1 roll put
    % var_array val_array
  } forall
  pop

  dup type [] type eq
  { dup length 0 eq
    { pop } if
  } if

  count 3 ge {
    3 -1 roll dup /call eq
    { 3 1 roll count 1 roll }
    { 3 1 roll exch }
    ifelse
  }
  { exch }
  ifelse
} def

/pop_var {
    dup vars exch get
    % varname varvalue
    dup length 0 ne
    {
      aload length 1 sub exch pop array
      %pstack
      %(1---\n) print
      astore
      % varname varvalues(len-1)
      vars 3 1 roll
      %pstack
      %(1---\n) print
      put
    } if
} def

/append_par_arr { % appends the par execution array to a lambda
   par_arr length 0 ne {
     dup length 6 add array
     dup 0
     { null
       { aload pop mydef3 pop }
       forall
     } dup 0 par_arr put putinterval
     dup 3 4 -1 roll putinterval
     dup dup length 3 sub
     { null
       { 0 get pop_var } forall
     } dup 0 par_arr put putinterval cvx

    % remove vars again
    % dup 0 5 -1 roll putinterval pstack
    % dup 3 -1 roll

    clear_par_arr
  } if
} def

/clear_par_arr {
  /par_arr 0 array def
} def

/clearpars {
  exch { pop_var } forall
} def

/isCall {
  count exch dup length 2 add 3 -1 roll lt
  { 3 -1 roll /call eq }
  { false }
  ifelse
} def

% (lambda (var...) exp) => [var..] { exp }
/lambda2
{
  %pstack
  %(1---\n) print
  12 array dup 0 % workaround
  % postscript fail --> it seems that postscript uses always the same reference here
  {
    %/function pop
    null
    null % array of par_names
    isCall
    16 array dup 0
    {
      setpars
     % null % function that needs to be executed
      pstack (3-----\n) print 
      getVal (4-----\n) print 
      pstack (5-----\n) print 
      clearpars (6-----\n) print 
      pstack (7-----\n) print 
    } putinterval cvx
    % dup 1 null put
    {
      % Composition here
      exch lambda2
      append_par_arr
      % pop (function)
    }
    ifelse
  } putinterval cvx
 % pstack
  %(2---\n) print
  dup 1 5 -1 roll 
  %pstack
  %(3---\n) print
  put
  dup 0 4 -1 roll
  %pstack
  %(4---\n) print
  put
  % pstack
  % (5---\n) print
} def

/callfun {
  /call exch
  knownVar
  { getVar3 }
  { exec }
  ifelse
} def

/eval % op p1..pn - evaluated
{
   % ] dup /actual exch def aload length -1 roll % creates array, puts items behind it on stack, moves last arrayitem on top (operator)
   counttomark -1 roll

   dup dictionary exch known % test if command is known
   { dictionary exch get exec }
   {
     { callfun }
     % dup vars exch known
     % { { getVar2 } }
     % { { cvi } }
     % ifelse
   }
   ifelse
   %(asdfasdfasdf) print pstack
   0 ] cvx dup dup length 1 sub {exec} putinterval
} def

/getVar3 {
  pstack
  vars exch get
  pstack
  dup length 1 sub get
  dup type {} type eq
  { exec }
  { cvi exch pop }
  ifelse
} def

/getVar2 {
  vars exch get
  dup length 1 sub get
  dup type {} type eq
  { exec }
  { cvi }
  ifelse
} def

/getVar {
  vars exch get cvi
} def

/clearvars % clear var dict
{
   /vars << >> def 
} def

/myset2 { % myset2 chrashes when var is not defined or wrong type (currently not checked)
  knownVar
  { vars exch get dup length 1 sub get } if
  % { vars exch get } if

  exch dup 3 1 roll mark exch % mark exch 3 -1 roll dup 4 1 roll
  vars exch get aload pop pop
  counttomark 2 add -1 roll dup ]

  vars 3 1 roll put
  ()
} def

/mydef3 {
  knownVar
  { vars exch get dup length 1 sub get } if
  % { vars exch get } if

  exch dup 3 1 roll mark exch % mark exch 3 -1 roll dup 4 1 roll
  
     % pstack
     % (2---\n) print
  knownVar
  { vars exch get aload 
  
      %pstack
      %(2---\n) print
  pop }
  { pop }
  ifelse
  counttomark 2 add -1 roll
      %pstack
      %(2---\n) print
      ]
  vars 3 1 roll 
  
      %pstack
      %(2---\n) print
  put
  ()
} def

/mydef2 {
  knownVar
  { vars exch get dup length 1 sub get } if

  exch dup 3 1 roll mark exch % mark exch 3 -1 roll dup 4 1 roll
  knownVar
  { vars exch get aload pop pop }
  { pop }
  ifelse
  counttomark 2 add -1 roll ]

  vars 3 1 roll put
  ()
} def

/mydef % name value - _ (add var to dict)
{
   knownVar
   { vars exch get }
   if
   vars 3 1 roll put
   ()
} def

/knownVar
{
  dup vars exch known
  { 
    dup vars exch get length 0 ne
  }
  { false }
  ifelse
} def

/getVal % value or varname - value
{
  knownVar
  { getVar2 }
  { dup type {} type eq
   { exec }
   { cvi }
   ifelse
  }
  ifelse
} def

/myop % 2x geVal
{
   getVal exch getVal exch
} def

/myadd % evaluates output if 2 integers are given or an array for later evaluation (lambda functions)
{
   2 copy % copy 2 parameter
   isInteger exch isInteger and % check if both are integer
   { add } % add the 2 integers
   { mark {add} 4 2 roll ] } % create array for later evaluation
   ifelse
} def

/mysub % evaluates output if 2 integers are given or an array for later evaluation (lambda functions)
{
   2 copy % copy 2 parameter
   isInteger exch isInteger and % check if both are integer
   { sub } % add the 2 integers
   { mark {sub} 4 2 roll ] } % create array for later evaluation
   ifelse
} def

/isInteger % (param - bool) tests if param is from type integer
{
   type 1 type eq % create "integertype" and compare
} def

/myif % checks if the "if" has an else part and evaluates the correct output
{
   makeExec % top item is everytime true part of if
   % checks if it is a if without else part
   1 index dup true bool2token eq
   exch false bool2token eq
   or 
   {  % if without else part
      exch token2bool exch % convert given token to bool
      { () }
      ifelse
   }
   {  % if with else part
      3 -1 roll token2bool 3 1 roll % convert given token to bool
      exch makeExec exch % make false part executable
      ifelse
   }
   ifelse
} def


/myif2 % checks if the "if" has an else part and evaluates the correct output
{
  3 -1 roll
  exec
  3 1 roll
  ifelse
} def

/makeExec % (item - {item}) makes top item of stack to executable array
{
   mark exch ] cvx
} def

/token2bool % (token - bool) false until tokenform of true given
{
   true bool2token eq
} def

/bool2token % (bool - token) gives token form of true|false
{
   {(true)}
   {(false)}
   ifelse
   token pop exch pop
} def

/quote % exp - exp
{
} def

% /quote % cmd... - {cmd...}
% {
%    actual cvx
% } def
% 
% /quote % (p[0] ... p[n] - [ p[0] ... p[n] ])
% {
%    actual length 1 sub dup dup % creates length of parameter
%    [ exch % sets marker between the "lengths"
%    3 add 1 roll % set the marker behind all parameters
%    {
%       exch % get parameter count behind top element
%       
%       dup isInteger not % test if its not an integer
%       { getTokenName } if % get name of token
%       
%       1 index 1 add 1 roll % get element in last position
%    } repeat % parameter count times
%    pop % drop length parameter
%    ] % create array so there is just 1 output element in eval
% } def
