/vars << >> def

/dictionary <<
(+) {myop add} (-) {myop sub} (*) {myop mul} (/) {myop div}
(not) {getval not} (>) {myop gt} (<) {myop lt} (>=) {myop ge} (<=) {myop le} (=) {myop eq}
(if) {myif2} (quote) {quote} (define) {mydef} (set!) {mydef} (begin) {begin}
(equal?) {pstack eq} (eq?) {} (length) {getval length} (cons) {} (car) {} (cdr) {} (append) {} (list) {} (list?) {} (null?) {} >> def

% doesn't work right now, marks are needed
/begin {
  {
    dup type {} type eq
    {
      exec
      dup type {} type eq not
      { pop }
      if
    }
    { exit }
    ifelse
  } loop
} def

/getVar {
  vars exch get cvi
} def

/eval % op p1..pn - evaluated
{
   % ] dup /actual exch def aload length -1 roll % creates array, puts items behind it on stack, moves last arrayitem on top (operator)
   counttomark -1 roll

   dup dictionary exch known % test if command is known
   { dictionary exch get }
   {
     dup vars exch known
     { { getVar } }
     { { cvi } }
     ifelse
   }
   ifelse
   0 ] cvx dup dup length 1 sub {exec} putinterval
} def

/clearvars % clear var dict
{
   /vars << >> def 
} def

/mydef % name value - _ (add var to dict)
{
   knownVar
   { vars exch get }
   if
   vars 3 1 roll put
   ()
}def

/knownVar
{
  dup vars exch known
} def

/getVal % value or varname - value
{
  knownVar
  { getVar }
  { dup type {} type eq
   { exec }
   { cvi }
   ifelse
  }
  ifelse
} def

/myop % 2x geVal
{
   getVal exch getVal exch
} def

/myadd % evaluates output if 2 integers are given or an array for later evaluation (lambda functions)
{
   2 copy % copy 2 parameter
   isInteger exch isInteger and % check if both are integer
   { add } % add the 2 integers
   { mark {add} 4 2 roll ] } % create array for later evaluation
   ifelse
} def

/mysub % evaluates output if 2 integers are given or an array for later evaluation (lambda functions)
{
   2 copy % copy 2 parameter
   isInteger exch isInteger and % check if both are integer
   { sub } % add the 2 integers
   { mark {sub} 4 2 roll ] } % create array for later evaluation
   ifelse
} def

/isInteger % (param - bool) tests if param is from type integer
{
   type 1 type eq % create "integertype" and compare
} def

/myif % checks if the "if" has an else part and evaluates the correct output
{
   makeExec % top item is everytime true part of if
   % checks if it is a if without else part
   1 index dup true bool2token eq
   exch false bool2token eq
   or 
   {  % if without else part
      exch token2bool exch % convert given token to bool
      { () }
      ifelse
   }
   {  % if with else part
      3 -1 roll token2bool 3 1 roll % convert given token to bool
      exch makeExec exch % make false part executable
      ifelse
   }
   ifelse
} def


/myif2 % checks if the "if" has an else part and evaluates the correct output
{
  3 -1 roll
  exec
  3 1 roll
  ifelse
} def

/makeExec % (item - {item}) makes top item of stack to executable array
{
   mark exch ] cvx
} def

/token2bool % (token - bool) false until tokenform of true given
{
   true bool2token eq
} def

/bool2token % (bool - token) gives token form of true|false
{
   {(true)}
   {(false)}
   ifelse
   token pop exch pop
} def

/quote % exp - exp
{
} def

% /quote % cmd... - {cmd...}
% {
%    actual cvx
% } def
% 
% /quote % (p[0] ... p[n] - [ p[0] ... p[n] ])
% {
%    actual length 1 sub dup dup % creates length of parameter
%    [ exch % sets marker between the "lengths"
%    3 add 1 roll % set the marker behind all parameters
%    {
%       exch % get parameter count behind top element
%       
%       dup isInteger not % test if its not an integer
%       { getTokenName } if % get name of token
%       
%       1 index 1 add 1 roll % get element in last position
%    } repeat % parameter count times
%    pop % drop length parameter
%    ] % create array so there is just 1 output element in eval
% } def
