
/dictionary <<(+) {myadd} (-) {mysub} (if) {myif}>> def

/myadd % evaluates output if 2 integers are given or an array for later evaluation (lambda functions)
{
   2 copy % copy 2 parameter
   isInteger exch isInteger and % check if both are integer
   { add } % add the 2 integers
   { mark {add} 4 2 roll ] } % create array for later evaluation
   ifelse
} def

/mysub % evaluates output if 2 integers are given or an array for later evaluation (lambda functions)
{
   2 copy % copy 2 parameter
   isInteger exch isInteger and % check if both are integer
   { sub } % add the 2 integers
   { mark {sub} 4 2 roll ] } % create array for later evaluation
   ifelse
} def

/isInteger % (param - bool) tests if param is from type integer
{
   type 1 type eq % create "integertype" and compare
} def

/myif % checks if the "if" has an else part and evaluates the correct output
{
   makeExec % top item is everytime true part of if
   
   % checks if it is a if without else part
   1 index dup true bool2token eq
   exch false bool2token eq
   or 
   
   {  % if without else part
      exch token2bool dup 3 -1 roll % convert given token to bool and duplicates it
      if 

      % if bool was false create an empty result
      not
      { () }
      if
   }
   {  % if with else part
      3 -1 roll token2bool 3 1 roll % convert given token to bool
      exch makeExec exch % make false part executable
      ifelse
   }
   ifelse
} def

/makeExec % (item - {item}) makes top item of stack to executable array
{
   mark exch ] cvx
} def

/token2bool % (token - bool) false until tokenform of true given
{
   true bool2token eq
} def

/bool2token % (bool - token) gives token form of true|false
{
   {(true)}
   {(false)}
   ifelse
   token pop exch pop
} def

/eval % op p1..pn - evaluated
{
   ] aload length -1 roll % creates array, puts items behind it on stack, moves last arrayitem on top (operator)
   dictionary begin % load dictionary for lisp commands
   load % load ps-definition for given lisp commando
   end  % remove lisp dictionary to avoid errors
   exec % exectute ps-definition to evaluate input
} def
